import{_ as t,c as a,l as s,a as i,a4 as l,o as n}from"./chunks/framework.C7sZLB-2.js";const f=JSON.parse('{"title":"闭包","description":"","frontmatter":{},"headers":[],"relativePath":"swift/closure.md","filePath":"swift/closure.md","lastUpdated":1714120847000}'),h={name:"swift/closure.md"},p=l(`<h1 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h1><iframe style="border:none;" width="100%" height="450" src="https://whimsical.com/embed/5sCTbd6Ny8inpxbCkbA7Qb"></iframe><p>闭包是自包含的函数代码块，允许你创建<strong>没有具体名称的函数结构</strong>，可以在代码中被传递和使用。</p><div class="info custom-block"><p class="custom-block-title">闭包的一个核心特性是它能够捕获周围上下文中的常量和变量</p><p>如果你在闭包内部使用了外部的变量或常量，即使闭包在其原始环境之外执行，它仍然可以访问并操作这些变量或常量。</p><p>Swift 会自动处理闭包中捕获的常量和变量的内存管理问题，你不需要担心内存泄漏或者变量生命周期的问题。</p><p>这意味着在使用闭包时，你可以专注于业务逻辑的实现，而不必过分关心底层的内存管理细节。</p></div><h2 id="闭包表达式" tabindex="-1">闭包表达式 <a class="header-anchor" href="#闭包表达式" aria-label="Permalink to &quot;闭包表达式&quot;">​</a></h2><p>嵌套函数是定义在另一个函数内部的函数，它可以帮助将复杂的函数分解成更小、更易管理的部分。</p><p>闭包表达式是 Swift 中一种用于构建内联闭包的简洁方式，它们通常用在需要将一个函数作为参数传递给另一个函数的场合。</p><p>让我们通过 <code>sorted(by:)</code> 的例子来看看如何通过多次迭代简化闭包的表达方式。</p><p>首先，我们从一个较为详细的闭包开始，然后逐步简化它：</p><ol><li><p><strong>完整的闭包表达式</strong>：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortedNumbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">s1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">s2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>这里，闭包完整地指定了参数类型和返回类型，并明确写出了返回语句。</p></li><li><p><strong>类型推断</strong>： 因为 Swift 能够推断闭包参数和返回值的类型，我们可以省略它们：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortedNumbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { s1, s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s2 })</span></span></code></pre></div><p>在这个版本中，我们省略了参数的类型声明，因为 Swift 能从上下文中推断出它们的类型。</p></li><li><p><strong>单表达式闭包隐式返回</strong>： 当闭包体只包含一个表达式时，该表达式的结果会自动作为闭包的返回值，所以我们可以省略 <code>return</code> 关键字：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortedNumbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { s1, s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s2 })</span></span></code></pre></div></li><li><p><strong>速记参数名称</strong>： Swift 自动为内联闭包提供了速记参数名称，如 <code>$0</code>, <code>$1</code> 等，这可以进一步简化表达式：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortedNumbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div></li><li><p><strong>运算符方法</strong>： 最后，因为 <code>&lt;</code> 本身是一个接受两个 <code>Int</code> 类型并返回 <code>Bool</code> 类型的函数，所以我们可以直接传递这个运算符：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sortedNumbers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sorted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></li></ol><h2 id="尾随闭包" tabindex="-1">尾随闭包 <a class="header-anchor" href="#尾随闭包" aria-label="Permalink to &quot;尾随闭包&quot;">​</a></h2><p>尾随闭包是 Swift 中一个语法特性，允许你在调用函数时，将一个较长的闭包表达式作为函数的最后一个参数传递 <code>{}</code>，而不是将其包含在函数的括号内 <code>()</code>。</p><h3 id="尾随闭包的使用" tabindex="-1">尾随闭包的使用 <a class="header-anchor" href="#尾随闭包的使用" aria-label="Permalink to &quot;尾随闭包的使用&quot;">​</a></h3><p>当函数的最后一个参数是闭包表达式时，闭包表达式直接跟在函数括号 <code>()</code> 之后写，不需要写在括号内。如果闭包是函数的唯一参数，则调用时甚至可以<strong>省略空的圆括号</strong>。</p><p>考虑一个简单的例子：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//原始写法</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFunctionThatTakesAClosure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">closure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 函数体部分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 以下是不使用尾随闭包进行函数调用</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">someFunctionThatTakesAClosure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">closure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 闭包主体部分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 以下是使用尾随闭包进行函数调用</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">someFunctionThatTakesAClosure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 闭包主体部分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 由于闭包是函数的最后一个（也是唯一一个）参数，你甚至可以省略调用时的空括号：</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">someFunctionThatTakesAClosure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 闭包主体部分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">尾随闭包的优势</p><ol><li><strong>提高可读性</strong>：尤其当闭包代码量较大时，将闭包作为尾随闭包书写可以使得函数调用看起来更加清晰。</li><li><strong>便于编写复杂闭包</strong>：尾随闭包的格式便于编写多行代码的闭包。</li><li><strong>代码结构清晰</strong>：帮助区分函数参数和闭包逻辑，特别是在闭包是最后一个或唯一一个参数的情况下。</li></ol></div><h2 id="值捕获" tabindex="-1">值捕获 <a class="header-anchor" href="#值捕获" aria-label="Permalink to &quot;值捕获&quot;">​</a></h2><p>想象你有一个小箱子，你可以在里面放一些东西（比如一个数字），然后你把这个箱子交给你的朋友。即使你离开了，你的朋友仍然可以打开箱子看里面的东西，甚至可以改变里面的东西。在 Swift 的闭包中，这个「箱子」就是闭包能够「捕获」变量的能力。</p><p>让我们看一个生活中的例子：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> greeting </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;World&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sayHello: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> greeting </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sayHello</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> helloMessage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> createMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">helloMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &quot;Hello World&quot;</span></span></code></pre></div><p>这里，<code>createMessage</code> 函数定义了两个变量 <code>greeting</code> 和 <code>message</code>，然后定义了一个闭包 <code>sayHello</code>。</p><ul><li><p>这个闭包通过简单地连接这两个字符串来创建一条消息。</p></li><li><p><strong>捕获行为</strong>：尽管 <code>createMessage</code> 函数的执行在返回闭包之后就结束了，这两个变量 <code>greeting</code> 和 <code>message</code> 仍然「活着」，因为闭包 <code>sayHello</code> 已经捕获了它们。即使外部函数的作用域已经结束，闭包仍然持有这些变量的访问权和它们的当前值。</p></li></ul><div class="tip custom-block"><p class="custom-block-title">关键点理解</p><ol><li><strong>生命周期延长</strong>：闭包使得变量即使在其定义的函数已经结束执行后，也可以继续存在。</li><li><strong>值复制</strong>：在闭包中，捕获的值类型变量是在闭包被创建时复制的。这意味着闭包内的变量和外部的变量虽然初始值相同，但是它们是独立的副本。</li><li><strong>引用和影响</strong>：如果闭包捕获的是引用类型的变量，那么闭包内外的修改将会相互影响，因为它们指向的是同一个对象。</li></ol></div><h2 id="闭包是引用类型" tabindex="-1">闭包是引用类型 <a class="header-anchor" href="#闭包是引用类型" aria-label="Permalink to &quot;闭包是引用类型&quot;">​</a></h2><p>当你把一个闭包赋值给一个变量或常量，或者将一个闭包作为参数传递给函数时，实际上传递的是对闭包的<strong>引用</strong>，而不是闭包的<strong>拷贝</strong>。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>引用类型的特性意味着如果你将一个闭包赋值给两个不同的变量，这两个变量将指向同一个闭包实例。</p><p>因此，如果闭包内部的状态发生变化，这种变化会反映在所有引用了这个闭包的变量上。</p></div><p>让我们通过一个例子来更直观地理解这一点：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> makeIncrementer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forIncrement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incrementer: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        total </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incrementer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incrementByFive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> makeIncrementer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">forIncrement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> alsoIncrementByFive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incrementByFive</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">incrementByFive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回 5</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">alsoIncrementByFive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回 10</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">incrementByFive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回 15</span></span></code></pre></div><p>在这个例子中：</p>`,30),e=s("code",null,"incrementByFive",-1),k=s("code",null,"total",-1),r={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},d={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.05ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.131ex",height:"1.557ex",role:"img",focusable:"false",viewBox:"0 -666 500 688","aria-hidden":"true"},E=s("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[s("g",{"data-mml-node":"math"},[s("g",{"data-mml-node":"mn"},[s("path",{"data-c":"35",d:"M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z",style:{"stroke-width":"3"}})])])],-1),g=[E],o=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mn",null,"5")])],-1),c=s("li",null,[s("code",null,"alsoIncrementByFive"),i(" 是对同一个闭包的另一个引用。")],-1),y=s("li",null,[i("因为闭包是引用类型，所以通过 "),s("code",null,"alsoIncrementByFive"),i(" 调用闭包，会影响到 "),s("code",null,"incrementByFive"),i("，反之亦然。它们都操作相同的 "),s("code",null,"total"),i(" 变量，因为它们实际上引用的是同一个闭包实例。")],-1),F=l(`<div class="tip custom-block"><p class="custom-block-title">关键点</p><ul><li><strong>状态共享</strong>：通过闭包的引用类型特性，多个变量可以共享对同一个闭包实例的引用，从而共享闭包内的状态。</li><li><strong>内存管理</strong>：Swift 使用引用计数来管理内存，这对于闭包也是适用的。如果一个闭包在其定义的范围之外被引用，Swift 会确保闭包所捕获的所有变量仍然存在，直到闭包本身不再被使用。</li></ul></div><h2 id="逃逸闭包" tabindex="-1">逃逸闭包 <a class="header-anchor" href="#逃逸闭包" aria-label="Permalink to &quot;逃逸闭包&quot;">​</a></h2><p>逃逸闭包是指在其被传入的函数返回之后才被调用的闭包。因为闭包逃离了它被定义的作用域，所以称为「逃逸」闭包。</p><p>你需要使用 <code>@escaping</code> 关键字来明确地标记一个闭包参数是逃逸的。</p><p>这告诉 Swift 编译器这个闭包可能在函数返回之后才被执行，因此编译器会做出相应的内存管理处理。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadFromNetwork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">completionHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@escaping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 模拟网络请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DispatchQueue.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">global</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 假设这里是从服务器获取到的数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fetchedData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Data from server&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DispatchQueue.main.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 回到主线程调用闭包</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            completionHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fetchedData)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loadFromNetwork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Received network data: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(data)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个例子中，<code>completionHandler</code> 是一个逃逸闭包，因为它在 <code>loadFromNetwork</code> 函数执行完毕后，由异步网络请求的回调触发。</p><div class="danger custom-block"><p class="custom-block-title">逃逸闭包的影响</p><ul><li><strong>内存管理</strong>：逃逸闭包可能需要额外的内存管理，因为 Swift 需要确保闭包内使用的所有捕获的资源在闭包执行时依然有效。</li><li><strong>生命周期</strong>：逃逸闭包的生命周期可能比函数长。因此，当你使用类实例的属性或方法时，需要小心循环引用问题。</li></ul></div><h2 id="自动闭包" tabindex="-1">自动闭包 <a class="header-anchor" href="#自动闭包" aria-label="Permalink to &quot;自动闭包&quot;">​</a></h2><p>自动闭包是一个自动创建的闭包，用于封装传递给函数作为参数的表达式。当函数需要这个参数的值时，闭包被执行，表达式的结果被返回。这样做的好处是，只有在需要其值的时候，表达式才会被求值。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>自动闭包是一个非常有用的功能，它允许你延迟执行某些表达式的计算，直到这个表达式真正需要被计算。这通常用在延迟求值的场景，尤其是在函数参数的处理上非常方便。</p></div><p>你可以通过在参数类型前使用 <code>@autoclosure</code> 标志来声明一个自动闭包。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> logIfTrue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> predicate: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@autoclosure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> predicate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;条件为真&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">logIfTrue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li>在这个例子中，<code>logIfTrue</code> 函数接受一个 <code>@autoclosure</code> 闭包作为参数。</li><li>当你调用 <code>logIfTrue(2 &gt; 1)</code> 时，<code>2 &gt; 1</code> 这个表达式被自动转换成闭包。</li><li>这个闭包在 <code>if</code> 语句内被调用，只有在实际需要判断条件时，表达式才被求值。</li></ul><p>自动闭包通常用在那些表达式需要被延迟计算的场景中，例如：</p><ul><li>延迟重计算，直到必要时才计算值。</li><li>控制语句内，仅当条件满足时才执行某些计算。</li><li>函数调用时，减少不必要的计算，提高性能。</li></ul><div class="warning custom-block"><p class="custom-block-title">注意事项</p><ul><li><strong>副作用</strong>：如果闭包内的表达式具有副作用，或者执行成本较高，你需要小心使用自动闭包，因为它可能导致不易察觉的错误或性能问题。</li><li><strong>逃逸与非逃逸</strong>：自动闭包可以是逃逸的或非逃逸的。如果你打算在函数返回后使用这个闭包，你需要标记为 <code>@escaping</code>。</li></ul></div>`,17);function u(C,m,A,D,b,v){return n(),a("div",null,[p,s("ul",null,[s("li",null,[e,i(" 是一个闭包，它每次被调用时都会将其内部的 "),k,i(" 变量增加 "),s("mjx-container",r,[(n(),a("svg",d,g)),o]),i("。")]),c,y]),F])}const w=t(h,[["render",u]]);export{f as __pageData,w as default};
