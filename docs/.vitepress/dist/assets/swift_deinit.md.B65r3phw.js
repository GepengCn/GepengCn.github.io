import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.C7sZLB-2.js";const E=JSON.parse('{"title":"析构过程","description":"","frontmatter":{},"headers":[],"relativePath":"swift/deinit.md","filePath":"swift/deinit.md","lastUpdated":1714218490000}'),e={name:"swift/deinit.md"},t=n(`<h1 id="析构过程" tabindex="-1">析构过程 <a class="header-anchor" href="#析构过程" aria-label="Permalink to &quot;析构过程&quot;">​</a></h1><iframe style="border:none;" width="100%" height="450" src="https://whimsical.com/embed/F3dSWwsTmobyeoMd2xdnJ9"></iframe><p>析构器<strong>只适用于类</strong>，当一个类的实例被释放之前，析构器会被立即调用。</p><p>析构器用关键字 <code>deinit</code> 来标示，类似于构造器要用 <code>init</code> 来标示。</p><h2 id="析构过程原理" tabindex="-1">析构过程原理 <a class="header-anchor" href="#析构过程原理" aria-label="Permalink to &quot;析构过程原理&quot;">​</a></h2><p>Swift 会自动释放不再需要的实例以释放资源。如 <a href="./arc.html">自动引用计数</a> 章节中所讲述，Swift 通过自动引用计数（ <code>ARC</code> ) 处理实例的内存管理。</p><p>通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。</p><div class="info custom-block"><p class="custom-block-title">例如</p><p>如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。</p></div><p>在类的定义中，每个类最多只能有一个析构器 <code>deinit</code>，而且析构器不带任何参数 <code>param</code> 和圆括号 <code>()</code>，如下所示：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">deinit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行析构过程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>析构器是在实例释放发生前被自动调用的。</li><li>你不能主动调用析构器。</li><li>子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。</li><li>即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</li></ul><p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性修改它的行为（比如查找一个需要被关闭的文件）。</p><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><p>假设我们有一个简单的 <code>Logger</code> 类，这个类负责在创建对象时记录一条日志，对象销毁时再记录一条日志，用以追踪对象的生命周期：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Logger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> identifier: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">identifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.identifier </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> identifier</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(identifier)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 已创建&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    deinit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(identifier)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 已销毁&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个 <code>Logger</code> 类中：</p><ul><li><code>init</code> 初始化方法设置了一个标识符，并打印一条消息表明对象已创建。</li><li><code>deinit</code> 析构器打印一条消息表明对象已销毁。</li></ul><p>你可以创建一个 <code>Logger</code> 实例，并观察它的生命周期：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testLogger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logger </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Logger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;测试日志器&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在这里 logger 正在被使用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当 testLogger 函数执行完毕后，logger 实例的生命周期结束，将调用析构器</span></span></code></pre></div><ul><li>当 <code>testLogger()</code> 函数执行并返回后，<code>logger</code> 变量超出了作用域范围。</li><li>由于没有其他引用指向这个 <code>Logger</code> 实例，它会被 Swift 的自动引用计数（ <code>ARC</code> ）系统销毁。</li><li>此时，<code>Logger</code> 的析构器 <code>deinit</code> 被调用，打印出 &quot;测试日志器 已销毁&quot; 的消息。</li></ul>`,20),l=[t];function p(h,k,d,r,o,c){return a(),i("div",null,l)}const y=s(e,[["render",p]]);export{E as __pageData,y as default};
