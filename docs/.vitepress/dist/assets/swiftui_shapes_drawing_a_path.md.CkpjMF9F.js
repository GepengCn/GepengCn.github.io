import{_ as e,c as a,l as s,a as i,a4 as t,o as n}from"./chunks/framework.C7sZLB-2.js";const q=JSON.parse('{"title":"绘制路径","description":"","frontmatter":{},"headers":[],"relativePath":"swiftui/shapes/drawing_a_path.md","filePath":"swiftui/shapes/drawing_a_path.md","lastUpdated":1715847340000}'),l={name:"swiftui/shapes/drawing_a_path.md"},h=t(`<h1 id="绘制路径" tabindex="-1">绘制路径 <a class="header-anchor" href="#绘制路径" aria-label="Permalink to &quot;绘制路径&quot;">​</a></h1><h2 id="move-to" tabindex="-1"><code>move(to:)</code> <a class="header-anchor" href="#move-to" aria-label="Permalink to &quot;\`move(to:)\`&quot;">​</a></h2><p>在指定点开始一个新的子路径。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end: CGPoint)</span></span></code></pre></div><h2 id="addarc-center-radius-startangle-endangle-clockwise-transform" tabindex="-1"><code>addArc(center:radius:startAngle:endAngle:clockwise:transform:)</code> <a class="header-anchor" href="#addarc-center-radius-startangle-endangle-clockwise-transform" aria-label="Permalink to &quot;\`addArc(center:radius:startAngle:endAngle:clockwise:transform:)\`&quot;">​</a></h2><p>向路径添加一个圆弧，用半径和角度指定。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addArc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGPoint,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    radius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGFloat,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    startAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Angle,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    endAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Angle,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    clockwise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGAffineTransform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,7),p=s("li",null,[s("code",null,"center"),i(": 圆弧的中心，在用户空间坐标中。")],-1),d=s("li",null,[s("code",null,"radius"),i(": 圆弧的半径，在用户空间坐标中。")],-1),k=s("code",null,"startAngle",-1),r={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},o={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.294ex",height:"1.025ex",role:"img",focusable:"false",viewBox:"0 -442 572 453","aria-hidden":"true"},c=s("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[s("g",{"data-mml-node":"math"},[s("g",{"data-mml-node":"mi"},[s("path",{"data-c":"1D465",d:"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z",style:{"stroke-width":"3"}})])])],-1),g=[c],E=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"x")])],-1),y=s("code",null,"endAngle",-1),u={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},F={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.294ex",height:"1.025ex",role:"img",focusable:"false",viewBox:"0 -442 572 453","aria-hidden":"true"},f=s("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[s("g",{"data-mml-node":"math"},[s("g",{"data-mml-node":"mi"},[s("path",{"data-c":"1D465",d:"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z",style:{"stroke-width":"3"}})])])],-1),m=[f],C=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"x")])],-1),b=s("li",null,[s("code",null,"clockwise"),i(": 为 "),s("code",null,"true"),i(" 时绘制顺时针圆弧；为 "),s("code",null,"false"),i(" 时绘制逆时针圆弧。")],-1),v=s("li",null,[s("code",null,"transform"),i(": 添加到路径之前应用于圆弧的仿射变换。如果未指定，则默认为恒等变换。")],-1),_=t(`<p>此方法使用你指定的半径和角度计算起点和终点，使用一系列三次贝塞尔曲线来近似这些点之间的圆段，然后将这些曲线附加到路径中。</p><p><code>clockwise</code> 参数确定创建圆弧的方向；最终路径的实际方向取决于 <code>transform</code> 参数和绘制路径的上下文的当前变换。然而，由于 SwiftUI 默认使用垂直翻转的坐标系（原点在视图的左上角），因此指定顺时针圆弧会在应用变换后得到逆时针圆弧。</p><p>如果路径以未闭合的子路径结束，则此方法会添加一条连接当前点和圆弧起点的线。如果没有未闭合的子路径，则此方法会创建一个新的子路径，其起点是圆弧的起点。圆弧的终点成为路径的新当前点。</p><h2 id="addarc-tangent1end-tangent2end-radius-transform" tabindex="-1"><code>addArc(tangent1End:tangent2End:radius:transform:)</code> <a class="header-anchor" href="#addarc-tangent1end-tangent2end-radius-transform" aria-label="Permalink to &quot;\`addArc(tangent1End:tangent2End:radius:transform:)\`&quot;">​</a></h2><p>向路径添加一段圆弧，通过半径和两条切线来指定。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addArc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    tangent1End</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGPoint,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    tangent2End</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGPoint,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    radius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGFloat,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGAffineTransform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li><code>tangent1End</code>：第一条切线的终点，在用户空间坐标中，用于构建圆弧。（这条切线的起点是路径的当前点。）</li><li><code>tangent2End</code>：第二条切线的终点，在用户空间坐标中，用于构建圆弧。（这条切线的起点是 <code>tangent1End</code> 点。）</li><li><code>radius</code>：圆弧的半径，在用户空间坐标中。</li><li><code>transform</code>：添加到路径之前应用于圆弧的仿射变换。如果未指定，则默认为恒等变换。</li></ul><p>此方法计算两条切线——第一条从当前点到 <code>tangent1End</code> 点，第二条从 <code>tangent1End</code> 点到 <code>tangent2End</code> 点——然后计算指定半径的圆弧的起点和终点，使得圆弧与两条切线都相切。最后，此方法使用一系列三次贝塞尔曲线来近似该圆弧，并将这些曲线附加到路径中。</p><p>如果圆弧的起点（即指定半径的圆必须与第一条切线相交的点，以便也与第二条切线相切）不是当前点，则此方法将从当前点到圆弧起点附加一个直线段。</p><p>圆弧的终点（即指定半径的圆必须与第二条切线相交的点，以便也与第一条切线相切）成为路径的新当前点。</p><h2 id="addcurve-to-control1-control2" tabindex="-1"><code>addCurve(to:control1:control2:)</code> <a class="header-anchor" href="#addcurve-to-control1-control2" aria-label="Permalink to &quot;\`addCurve(to:control1:control2:)\`&quot;">​</a></h2><p>向路径添加一条三次贝塞尔曲线，具有指定的终点和控制点。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addCurve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end: CGPoint,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    control1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGPoint,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    control2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGPoint</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li><code>control1</code>：曲线的第一个控制点，在用户空间坐标中。</li><li><code>control2</code>：曲线的第二个控制点，在用户空间坐标中。</li></ul><p>此方法构建一条从路径的当前点开始并结束于指定终点的曲线，其曲率由两个控制点定义。此方法将该曲线附加到当前路径后，曲线的终点将成为路径的当前点。</p><h2 id="addellipse-in-transform" tabindex="-1"><code>addEllipse(in:transform:)</code> <a class="header-anchor" href="#addellipse-in-transform" aria-label="Permalink to &quot;\`addEllipse(in:transform:)\`&quot;">​</a></h2><p>向路径添加一个适合指定矩形内部的椭圆。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addEllipse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rect: CGRect,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGAffineTransform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>椭圆由一系列贝塞尔曲线近似。它的中心是由 <code>rect</code> 参数定义的矩形的中点。如果矩形是正方形，则椭圆是圆形的，半径等于矩形宽度（或高度）的一半。如果 <code>rect</code> 参数指定的是矩形形状，则椭圆的长轴和短轴由矩形的宽度和高度定义。</p><p>椭圆形成路径的一个完整子路径——也就是说，椭圆绘制从一个移动到操作开始，以一个闭合子路径操作结束，所有的移动都沿顺时针方向。</p><p>参数：</p><ul><li><code>rect</code>：一个定义椭圆适合区域的矩形。</li><li><code>transform</code>：添加到路径之前应用于椭圆的仿射变换。如果未指定，则默认为恒等变换。</li></ul><h2 id="addline-to" tabindex="-1"><code>addLine(to:)</code> <a class="header-anchor" href="#addline-to" aria-label="Permalink to &quot;\`addLine(to:)\`&quot;">​</a></h2><p>从当前点到指定点附加一条直线段。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addLine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end: CGPoint)</span></span></code></pre></div><ul><li><code>end</code>：新线段终点的位置，在用户空间坐标中。</li></ul><p>添加线段后，当前点设置为线段的终点。</p><h2 id="addlines" tabindex="-1"><code>addLines(_:)</code> <a class="header-anchor" href="#addlines" aria-label="Permalink to &quot;\`addLines(_:)\`&quot;">​</a></h2><p>向路径添加一系列连接的直线段。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addLines</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lines: [CGPoint])</span></span></code></pre></div><p>调用此便利方法等同于将变换应用于数组中的所有点，然后使用 <code>points</code> 数组中的第一个值调用 <code>move(to:)</code>方法，然后对每个后续点调用 <code>addLine(to:)</code> 方法，直到数组用完。调用此方法后，路径的当前点是数组中的最后一个点。</p><p>参数：</p><ul><li><code>lines</code>：一个值数组，指定要绘制的线段的起点和终点。数组中的每个点指定用户空间中的一个位置。数组中的第一个点指定初始起点。</li><li><code>transform</code>：添加到路径之前应用于点的仿射变换。如果未指定，则默认为恒等变换。</li></ul><h2 id="addpath-transform" tabindex="-1"><code>addPath(_:transform:)</code> <a class="header-anchor" href="#addpath-transform" aria-label="Permalink to &quot;\`addPath(_:transform:)\`&quot;">​</a></h2><p>将另一个路径值附加到此路径。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path: Path,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGAffineTransform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li><code>path</code>：要添加的路径。</li><li><code>transform</code>：在将 <code>path</code> 参数添加到此路径之前应用的仿射变换。如果未指定，则默认为恒等变换。</li></ul><p>如果 <code>path</code> 参数是一个非空路径，其元素将按顺序附加到此路径。之后，此路径的起始点和当前点是 <code>path</code> 参数中最后一个子路径的起始点和当前点。</p><h2 id="addquadcurve-to-control" tabindex="-1"><code>addQuadCurve(to:control:)</code> <a class="header-anchor" href="#addquadcurve-to-control" aria-label="Permalink to &quot;\`addQuadCurve(to:control:)\`&quot;">​</a></h2><p>向路径添加一条二次贝塞尔曲线，具有指定的终点和控制点。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addQuadCurve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end: CGPoint,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    control</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGPoint</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>此方法构建一条从路径的当前点开始并结束于指定终点的曲线，其曲率由控制点定义。此方法将该曲线附加到当前路径后，曲线的终点将成为路径的当前点。</p><h2 id="addrect-transform" tabindex="-1"><code>addRect(_:transform:)</code> <a class="header-anchor" href="#addrect-transform" aria-label="Permalink to &quot;\`addRect(_:transform:)\`&quot;">​</a></h2><p>向路径添加一个矩形子路径。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rect: CGRect,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGAffineTransform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li><code>rect</code>：一个矩形，在用户空间坐标中指定。</li><li><code>transform</code>：在将矩形添加到路径之前应用的仿射变换。如果未指定，则默认为恒等变换。</li></ul><p>这是一个便利函数，用于向路径添加一个矩形，首先移动到底部左角，然后逆时针添加线条以创建一个矩形，最后闭合子路径。</p><h2 id="addrects-transform" tabindex="-1"><code>addRects(_:transform:)</code> <a class="header-anchor" href="#addrects-transform" aria-label="Permalink to &quot;\`addRects(_:transform:)\`&quot;">​</a></h2><p>向路径添加一组矩形子路径。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addRects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rects: [CGRect],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGAffineTransform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>调用此便利方法等同于对数组中的每个矩形重复调用 <code>addRect(_:transform:)</code> 方法。</p><p>参数：</p><ul><li><code>rects</code>：一个矩形数组，在用户空间坐标中指定。</li><li><code>transform</code>：在将椭圆添加到路径之前应用的仿射变换。如果未指定，则默认为恒等变换。</li></ul><h2 id="addrelativearc-center-radius-startangle-delta-transform" tabindex="-1"><code>addRelativeArc(center:radius:startAngle:delta:transform:)</code> <a class="header-anchor" href="#addrelativearc-center-radius-startangle-delta-transform" aria-label="Permalink to &quot;\`addRelativeArc(center:radius:startAngle:delta:transform:)\`&quot;">​</a></h2><p>向路径添加一段圆弧，通过半径和角度差来指定。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addRelativeArc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGPoint,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    radius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGFloat,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    startAngle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Angle,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    delta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Angle,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGAffineTransform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li><code>center</code>：圆弧的中心，在用户空间坐标中。</li><li><code>radius</code>：圆弧的半径，在用户空间坐标中。</li><li><code>startAngle</code>：圆弧起始点的角度，从正 x 轴开始测量。</li><li><code>delta</code>：圆弧起始角度和结束角度之间的差值。正值创建逆时针圆弧（在用户空间坐标中），反之亦然。</li><li><code>transform</code>：在将圆弧添加到路径之前应用的仿射变换。如果未指定，则默认为恒等变换。</li></ul><p>此方法使用你指定的半径和角度计算起始点和结束点，使用一系列三次贝塞尔曲线来近似这些点之间的一段圆弧，然后将这些曲线附加到路径中。</p><p><code>delta</code> 参数同时确定圆弧的长度和创建圆弧的方向；最终路径的实际方向取决于 <code>transform</code> 参数和绘制路径的上下文的当前变换。然而，由于 SwiftUI 默认使用垂直翻转的坐标系（原点在视图的左上角），因此指定顺时针圆弧会在应用变换后得到逆时针圆弧。</p><p>如果路径以未闭合的子路径结束，此方法将添加一条连接当前点到圆弧起始点的直线。如果没有未闭合的子路径，此方法将创建一个新的子路径，其起始点是圆弧的起始点。圆弧的结束点成为路径的新当前点。</p><h2 id="addroundedrect-in-cornersize-style-transform" tabindex="-1"><code>addRoundedRect(in:cornerSize:style:transform:)</code> <a class="header-anchor" href="#addroundedrect-in-cornersize-style-transform" aria-label="Permalink to &quot;\`addRoundedRect(in:cornerSize:style:transform:)\`&quot;">​</a></h2><p>向路径添加一个圆角矩形。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addRoundedRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rect: CGRect,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    cornerSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGSize,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: RoundedCornerStyle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .continuous,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGAffineTransform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li><code>rect</code>：一个矩形，在用户空间坐标中指定。</li><li><code>cornerSize</code>：角的大小，在用户空间坐标中指定。</li><li><code>style</code>：角的样式。如果未指定，则默认为连续样式。</li><li><code>transform</code>：在将矩形添加到路径之前应用的仿射变换。如果未指定，则默认为恒等变换。</li></ul><p>这是一个便利函数，用于向路径添加一个圆角矩形，首先移动到右边缘的中心，然后逆时针添加线条和曲线以创建一个圆角矩形，最后闭合子路径。</p><h2 id="closesubpath" tabindex="-1"><code>closeSubpath()</code> <a class="header-anchor" href="#closesubpath" aria-label="Permalink to &quot;\`closeSubpath()\`&quot;">​</a></h2><p>关闭并完成当前子路径。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> closeSubpath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>从当前点到当前子路径的起始点附加一条线，并结束子路径。</p><p>关闭子路径后，你的应用程序可以开始一个新的子路径，而无需先调用 <code>move(to:)</code>。在这种情况下，会隐式创建一个新的子路径，其起始点和当前点等于前一个子路径的起始点。</p><h2 id="addroundedrect-in-cornersize-style-transform-1" tabindex="-1"><code>addRoundedRect(in:cornerSize:style:transform:)</code> <a class="header-anchor" href="#addroundedrect-in-cornersize-style-transform-1" aria-label="Permalink to &quot;\`addRoundedRect(in:cornerSize:style:transform:)\`&quot;">​</a></h2><p>向路径添加一个圆角矩形。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mutating</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addRoundedRect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rect: CGRect,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    cornerSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGSize,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: RoundedCornerStyle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .continuous,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: CGAffineTransform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li><code>rect</code>：一个矩形，在用户空间坐标中指定。</li><li><code>cornerSize</code>：角的大小，在用户空间坐标中指定。</li><li><code>style</code>：角的样式。如果未指定，则默认为连续样式。</li><li><code>transform</code>：在将矩形添加到路径之前应用的仿射变换。如果未指定，则默认为恒等变换。</li></ul><p>这是一个便利函数，它将一个圆角矩形添加到路径中，首先移动到右边缘的中心，然后逆时针添加线条和曲线来创建圆角矩形，最后闭合子路径。</p><h2 id="intersection-eofill" tabindex="-1"><code>intersection(_:eoFill:)</code> <a class="header-anchor" href="#intersection-eofill" aria-label="Permalink to &quot;\`intersection(_:eoFill:)\`&quot;">​</a></h2><p>返回一个新路径，该路径具有两个路径共有的填充区域。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> intersection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other: Path,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    eoFill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path</span></span></code></pre></div><ul><li><code>other</code>：要相交的路径。</li><li><code>eoFill</code>：是否使用奇偶规则来确定哪些区域视为路径的内部（如果为 <code>true</code>），还是使用非零规则（如果为 <code>false</code>）。</li></ul><p>生成的路径的填充区域是两个路径的填充区域的重叠区域。这可用于将路径的填充裁剪到蒙版。</p><p>任何未闭合的子路径都被假定为已闭合。使用奇偶填充规则或非零填充规则填充此路径的结果是相同的。</p><h2 id="lineintersection-eofill" tabindex="-1"><code>lineIntersection(_:eoFill:)</code> <a class="header-anchor" href="#lineintersection-eofill" aria-label="Permalink to &quot;\`lineIntersection(_:eoFill:)\`&quot;">​</a></h2><p>返回一个新路径，该路径具有与此路径重叠的给定路径的填充区域的线条。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lineIntersection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other: Path,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    eoFill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path</span></span></code></pre></div><p>生成的路径的线条是此路径与其他路径的填充区域重叠的线条。</p><p>被裁剪的相交子路径创建开放子路径。不与其他路径相交的闭合子路径保持闭合。</p><h2 id="linesubtraction-eofill" tabindex="-1"><code>lineSubtraction(_:eoFill:)</code> <a class="header-anchor" href="#linesubtraction-eofill" aria-label="Permalink to &quot;\`lineSubtraction(_:eoFill:)\`&quot;">​</a></h2><p>返回一个新路径，该路径具有与此路径不重叠的给定路径的填充区域的线条。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lineSubtraction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other: Path,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    eoFill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path</span></span></code></pre></div><h2 id="normalized-eofill" tabindex="-1"><code>normalized(eoFill:)</code> <a class="header-anchor" href="#normalized-eofill" aria-label="Permalink to &quot;\`normalized(eoFill:)\`&quot;">​</a></h2><p>返回此路径的一个新的弱简单副本。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> normalized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eoFill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path</span></span></code></pre></div><p>返回的路径是弱简单路径，没有自相交，并且具有归一化的方向。使用奇偶填充规则或非零填充规则填充此路径的结果是相同的。</p><h2 id="subtracting-eofill" tabindex="-1"><code>subtracting(_:eoFill:)</code> <a class="header-anchor" href="#subtracting-eofill" aria-label="Permalink to &quot;\`subtracting(_:eoFill:)\`&quot;">​</a></h2><p>返回一个新路径，该路径包含此路径中不在给定路径中的填充区域。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subtracting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other: Path,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    eoFill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path</span></span></code></pre></div><p>生成的路径的填充区域是此路径的填充区域减去其他路径的填充区域。</p><p>任何未闭合的子路径都被假定为已闭合。使用奇偶填充规则或非零填充规则填充此路径的结果是相同的。</p><h2 id="symmetricdifference-eofill" tabindex="-1"><code>symmetricDifference(_:eoFill:)</code> <a class="header-anchor" href="#symmetricdifference-eofill" aria-label="Permalink to &quot;\`symmetricDifference(_:eoFill:)\`&quot;">​</a></h2><p>返回一个新路径，该路径的填充区域要么来自此路径，要么来自给定路径，但不能同时来自两者。</p><p>生成的路径的填充区域是包含在此路径或其他路径中的填充区域，但不是两者都包含。</p><p>任何未闭合的子路径都被假定为已闭合。使用奇偶填充规则或非零填充规则填充此路径的结果是相同的。</p><h2 id="union-eofill" tabindex="-1"><code>union(_:eoFill:)</code> <a class="header-anchor" href="#union-eofill" aria-label="Permalink to &quot;\`union(_:eoFill:)\`&quot;">​</a></h2><p>返回一个新路径，该路径的填充区域在此路径或给定路径中。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> union</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    _</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> other: Path,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    eoFill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path</span></span></code></pre></div><p>生成的路径的填充区域是两个路径的填充区域的组合。</p><p>任何未闭合的子路径都被假定为已闭合。使用奇偶填充规则或非零填充规则填充此路径的结果是相同的。</p><h2 id="foreach" tabindex="-1"><code>forEach(_:)</code> <a class="header-anchor" href="#foreach" aria-label="Permalink to &quot;\`forEach(_:)\`&quot;">​</a></h2><p>对路径中的每个元素调用 <code>body</code>。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> body: (Path.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="strokedpath" tabindex="-1"><code>strokedPath(_:)</code> <a class="header-anchor" href="#strokedpath" aria-label="Permalink to &quot;\`strokedPath(_:)\`&quot;">​</a></h2><p>使用 <code>style</code> 定义如何创建描边轮廓，返回路径的描边副本。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strokedPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> style: StrokeStyle) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Path</span></span></code></pre></div>`,113);function B(A,w,x,D,Q,T){return n(),a("div",null,[h,s("ul",null,[p,d,s("li",null,[k,i(": 从正 "),s("mjx-container",r,[(n(),a("svg",o,g)),E]),i(" 轴测量到圆弧起点的角度。")]),s("li",null,[y,i(": 从正 "),s("mjx-container",u,[(n(),a("svg",F,m)),C]),i(" 轴测量到圆弧终点的角度。")]),b,v]),_])}const G=e(l,[["render",B]]);export{q as __pageData,G as default};
