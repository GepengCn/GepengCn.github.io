import{_ as s,c as i,o as a,a4 as e}from"./chunks/framework.C7sZLB-2.js";const E=JSON.parse('{"title":"访问控制","description":"","frontmatter":{},"headers":[],"relativePath":"swift/access_control.md","filePath":"swift/access_control.md","lastUpdated":1714303794000}'),n={name:"swift/access_control.md"},t=e(`<h1 id="访问控制" tabindex="-1">访问控制 <a class="header-anchor" href="#访问控制" aria-label="Permalink to &quot;访问控制&quot;">​</a></h1><iframe style="border:none;" width="100%" height="450" src="https://whimsical.com/embed/ySRPWMrPMdKj477ro9Y4w"></iframe><p><strong>访问控制可以限定其它源文件或模块对你的代码的访问</strong>。</p><ul><li>这个特性可以让你「隐藏代码的实现细节」，并且能提供一个接口来让别人访问和使用你的代码。</li></ul><p>你可以明确地给：</p><ul><li>单个类型（类、结构体、枚举）设置访问级别。</li><li>也可以给这些类型的属性、方法、构造器、下标等设置访问级别。</li><li>协议也可以被限定在一定访问级别的范围内使用，包括协议里的全局常量、变量和函数。</li></ul><div class="info custom-block"><p class="custom-block-title">默认的访问级别</p><p>Swift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都显式声明访问级别。</p><p>如果你只是开发一个单 target 的应用程序，完全可以不用显式声明代码的访问级别。</p></div><p>为了简单起见，对于代码中可以设置访问级别的特性（属性、基本类型、函数等），在下面的章节中我们会统一称之为「<strong>实体</strong>」。</p><h2 id="模块和源文件" tabindex="-1">模块和源文件 <a class="header-anchor" href="#模块和源文件" aria-label="Permalink to &quot;模块和源文件&quot;">​</a></h2><p>Swift 中的访问控制模型基于「模块」和「源文件」这两个概念。</p><div class="tip custom-block"><p class="custom-block-title">模块</p><p>独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。</p><p>在 Swift 中，一个模块可以使用 <code>import</code> 关键字导入另外一个模块。</p></div><p>在 Swift 中，<code>Xcode</code> 的每个 <code>target</code>（例如框架或应用程序）都被当作独立的模块处理。</p><ul><li>如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。</li><li>当它被导入到某个应用程序或者其他框架时，框架的内容都将属于这个独立的模块。</li></ul><div class="tip custom-block"><p class="custom-block-title">源文件</p><p>Swift 模块中的源代码文件（实际上，源文件属于一个应用程序或框架）。</p><p>尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数等的定义。</p></div><h2 id="访问级别" tabindex="-1">访问级别 <a class="header-anchor" href="#访问级别" aria-label="Permalink to &quot;访问级别&quot;">​</a></h2><p>Swift 为代码中的实体提供了五种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。</p><div class="tip custom-block"><p class="custom-block-title"><code>open</code> &amp; <code>public</code></p><p>可以让实体被同一模块源文件中的所有实体访问，在模块外也可以通过导入该模块来访问源文件里的所有实体。</p><p>通常情况下，你会使用 <code>open</code> 或 <code>public</code> 级别来指定框架的外部接口。</p><p><code>open</code> 和 <code>public</code> 的区别在后面会提到。</p></div><div class="info custom-block"><p class="custom-block-title"><code>internal</code></p><p>让实体被同一模块源文件中的任何实体访问，但是不能被模块外的实体访问。</p><p>通常情况下，如果某个接口只在应用程序或框架内部使用，就可以将其设置为 internal 级别。</p></div><div class="warning custom-block"><p class="custom-block-title"><code>fileprivate</code></p><p>限制实体只能在其定义的文件内部访问。</p><p>如果功能的部分实现细节只需要在文件内使用时，可以使用 <code>fileprivate</code> 来将其隐藏。</p></div><div class="danger custom-block"><p class="custom-block-title"><code>private</code></p><p>限制实体只能在其定义的作用域，以及同一文件内的 <code>extension</code> 访问。</p><p>如果功能的部分细节只需要在当前作用域内使用时，可以使用 <code>private</code> 来将其隐藏。</p></div><p><code>open</code> 为最高访问级别（限制最少），<code>private</code> 为最低访问级别（限制最多）。</p><div class="info custom-block"><p class="custom-block-title"><code>open</code> 和 <code>public</code> 的区别</p><ul><li><code>open</code> 只能作用于类和类的成员，它和 <code>public</code> 的区别主要在于 <code>open</code> 限定的类和成员能够在模块外被继承和重写。</li><li>将类的访问级别显式指定为 <code>open</code> 表明你已经设计好了类的代码，并且充分考虑过这个类在其他模块中用作父类时的影响。</li></ul></div><h3 id="访问级别基本原则" tabindex="-1">访问级别基本原则 <a class="header-anchor" href="#访问级别基本原则" aria-label="Permalink to &quot;访问级别基本原则&quot;">​</a></h3><p>Swift 中的访问级别遵循一个基本原则：<strong>实体不能定义在具有更低访问级别（更严格）的实体中</strong>。</p><p>例如：</p><ul><li><p>一个 <code>public</code> 的变量，其类型的访问级别不能是 <code>internal</code>，<code>fileprivate</code> 或是 <code>private</code>。因为无法保证变量的类型在使用变量的地方也具有访问权限。</p></li><li><p>函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就不会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以的情况。</p></li></ul><h3 id="默认访问级别" tabindex="-1">默认访问级别 <a class="header-anchor" href="#默认访问级别" aria-label="Permalink to &quot;默认访问级别&quot;">​</a></h3><p>你代码中所有的实体，如果你不显式的指定它们的访问级别，那么它们将都有一个 <code>internal</code> 的默认访问级别，（有一些例外情况，本文稍后会有说明）。</p><p>因此，多数情况下你不需要显式指定实体的访问级别。</p><h3 id="single-target-应用程序的访问级别" tabindex="-1">single-target 应用程序的访问级别 <a class="header-anchor" href="#single-target-应用程序的访问级别" aria-label="Permalink to &quot;single-target 应用程序的访问级别&quot;">​</a></h3><p>当你编写一个单 <code>target</code> 应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以你不需要明确设置访问级别，使用默认的访问级别 <code>internal</code> 即可。</p><p>但是，你也可以使用 <code>fileprivate</code> 或 <code>private</code> 访问级别，用于隐藏一些功能的实现细节。</p><h3 id="框架的访问级别" tabindex="-1">框架的访问级别 <a class="header-anchor" href="#框架的访问级别" aria-label="Permalink to &quot;框架的访问级别&quot;">​</a></h3><p>当你开发框架时，就需要把一些对外的接口定义为 <code>open</code> 或 <code>public</code> 访问级别，以便使用者导入该框架后可以正常使用其功能。</p><p>这些被你定义为对外的接口，就是这个框架的 API。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>框架的内部实现仍然可以使用默认的访问级别 <code>internal</code>，当你需要对框架内部其它部分隐藏细节时可以使用 <code>private</code> 或 <code>fileprivate</code>。</p><p>对于框架的对外 API 部分，你就需要将它们设置为 <code>open</code> 或 <code>public</code> 了。</p></div><h3 id="unit-test-target-访问级别" tabindex="-1">Unit Test Target 访问级别 <a class="header-anchor" href="#unit-test-target-访问级别" aria-label="Permalink to &quot;Unit Test Target 访问级别&quot;">​</a></h3><p>当你的应用程序包含 <code>Unit Test Target</code> 时，为了测试，测试模块需要访问应用程序模块中的代码。</p><p>默认情况下只有 <code>open</code> 或 <code>public</code> 级别的实体才可以被其他模块访问。</p><p>然而，如果在导入应用程序模块的语句前使用 <code>@testable</code>特性，然后在允许测试的编译设置（ <code>Build Options -&gt; Enable Testability</code> ）下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有<strong>内部级别的实体</strong>。</p><h2 id="访问控制语法" tabindex="-1">访问控制语法 <a class="header-anchor" href="#访问控制语法" aria-label="Permalink to &quot;访问控制语法&quot;">​</a></h2><p>通过修饰符 <code>open</code>、<code>public</code>、<code>internal</code>、<code>fileprivate</code>、<code>private</code> 来声明实体的访问级别：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomePublicClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">internal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeInternalClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fileprivate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeFilePrivateClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomePrivateClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> somePublicVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">internal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someInternalConstant </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fileprivate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFilePrivateFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> somePrivateFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span></code></pre></div><p><strong>除非专门指定，否则实体默认的访问级别为 <code>internal</code></strong>。</p><p>这意味着在不使用修饰符显式声明访问级别的情况下，<code>SomeInternalClass</code> 和 <code>someInternalConstant</code> 的访问级别是 <code>internal</code>：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeInternalClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 隐式 internal</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someInternalConstant </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 隐式 internal</span></span></code></pre></div><h2 id="自定义类型" tabindex="-1">自定义类型 <a class="header-anchor" href="#自定义类型" aria-label="Permalink to &quot;自定义类型&quot;">​</a></h2><p>可以在定义类型时指定它的访问级别，而且只能在它的访问级别的限制范围内使用。</p><p>例如，你定义了一个 <code>fileprivate</code> 级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型等等。</p><div class="info custom-block"><p class="custom-block-title">一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别。</p><ul><li>如果你将类型指定为 <code>private</code> 或者 <code>fileprivate</code> 级别，那么该类型的所有成员的默认访问级别也会变成 <code>private</code> 或者 <code>fileprivate</code> 级别。</li><li>如果你将类型指定为 <code>internal</code> 或 <code>public</code>（或者不明确指定访问级别，而使用默认的 <code>internal</code> ），那么该类型的所有成员的默认访问级别将是 <code>internal</code>。</li></ul></div><div class="tip custom-block"><p class="custom-block-title">重点</p><p>上面提到，一个 <code>public</code> 类型的所有成员的访问级别默认为 <code>internal</code> 级别，而不是 <code>public</code> 级别。</p><p><strong>如果你想将某个成员指定为 <code>public</code> 级别，那么你必须「显式」指定</strong>。</p><p>这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。</p></div><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomePublicClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显式 public 类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> somePublicProperty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 显式 public 类成员</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someInternalProperty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // 隐式 internal 类成员</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fileprivate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFilePrivateMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显式 fileprivate 类成员</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> somePrivateMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显式 private 类成员</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeInternalClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {                       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 隐式 internal 类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someInternalProperty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // 隐式 internal 类成员</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fileprivate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFilePrivateMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显式 fileprivate 类成员</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> somePrivateMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显式 private 类成员</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fileprivate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeFilePrivateClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显式 fileprivate 类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFilePrivateMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 隐式 fileprivate 类成员</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> somePrivateMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显式 private 类成员</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomePrivateClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显式 private 类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> somePrivateMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 隐式 private 类成员</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="元组类型" tabindex="-1">元组类型 <a class="header-anchor" href="#元组类型" aria-label="Permalink to &quot;元组类型&quot;">​</a></h3><p>元组的访问级别将由元组中「<strong>访问级别最严格的类型</strong>」来决定。</p><p>例如，如果你构建了一个包含两种不同类型的元组：</p><ul><li>其中一个类型为 <code>internal</code></li><li>另一个类型为 <code>private</code></li></ul><p>那么这个元组的访问级别为 <code>private</code>。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>元组不同于类、结构体、枚举、函数那样有单独的定义。</p><p>一个元组的访问级别是由元组中<strong>元素的访问级别</strong>来决定的，不能被显式指定。</p></div><h3 id="函数类型" tabindex="-1">函数类型 <a class="header-anchor" href="#函数类型" aria-label="Permalink to &quot;函数类型&quot;">​</a></h3><p>函数的访问级别根据<strong>访问级别最严格的参数类型或返回类型</strong>的访问级别来决定。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。</p></div><p>下面的例子定义了一个名为 <code>someFunction()</code> 的全局函数，并且没有明确地指定其访问级别。</p><p>也许你会认为该函数应该拥有默认的访问级别 <code>internal</code>，但事实并非如此。</p><p>事实上，如果按下面这种写法，代码将无法通过编译：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark has-highlighted vp-code"><code><span class="line highlighted error"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (SomeInternalClass, SomePrivateClass) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 此处是函数实现部分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类。</p><ul><li>其中一个类的访问级别是 <code>internal</code></li><li>另一个的访问级别是 <code>private</code></li></ul><p>所以根据元组访问级别的原则，该元组的访问级别是 <code>private</code>（元组的访问级别与元组中访问级别最低的类型一致）。</p><p>因为该函数返回类型的访问级别是 <code>private</code>，所以你<strong>必须使用 <code>private</code> 修饰符来明确指定该函数的访问级别</strong>：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark has-diff vp-code"><code><span class="line diff remove"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (SomeInternalClass, SomePrivateClass) { </span></span>
<span class="line diff add"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (SomeInternalClass, SomePrivateClass) { </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 此处是函数实现部分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">错误</p><p>将该函数指定为 <code>public</code> 或 <code>internal</code>，或者使用默认的访问级别 <code>internal</code> 都是错误的，因为如果把该函数当做 <code>public</code> 或 <code>internal</code> 级别来使用的话，可能会无法访问 <code>private</code> 级别的返回值。</p></div><h3 id="枚举类型" tabindex="-1">枚举类型 <a class="header-anchor" href="#枚举类型" aria-label="Permalink to &quot;枚举类型&quot;">​</a></h3><p>枚举成员的访问级别和<strong>该枚举类型相同</strong>，你不能为枚举成员单独指定不同的访问级别。</p><p>比如下面的例子：</p><ul><li>枚举 <code>CompassPoint</code> 被明确指定为 <code>public</code></li><li>那么它的成员 <code>north</code>、<code>south</code>、<code>east</code>、<code>west</code> 的访问级别同样也是 <code>public</code>：</li></ul><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CompassPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> north</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> south</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> east</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> west</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">原始值和关联值</p><p>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。</p><p>例如，你不能在一个 <code>internal</code> 的枚举中定义 <code>private</code> 的原始值类型。</p></div><h3 id="嵌套类型" tabindex="-1">嵌套类型 <a class="header-anchor" href="#嵌套类型" aria-label="Permalink to &quot;嵌套类型&quot;">​</a></h3><p>嵌套类型的访问级别和<strong>包含它的「类」的访问级别相同</strong>，嵌套类型是 <code>public</code> 的情况除外。</p><p>在一个 <code>public</code> 的类中定义嵌套类型，那么嵌套类型自动拥有 <code>internal</code> 的访问级别。</p><p>如果你想让嵌套类型拥有 <code>public </code>访问级别，那么必须显式指定该嵌套类型的访问级别为 <code>public</code>。</p><h2 id="子类" tabindex="-1">子类 <a class="header-anchor" href="#子类" aria-label="Permalink to &quot;子类&quot;">​</a></h2><p>你可以继承同一模块中的所有有访问权限的类，也可以继承不同模块中被 <code>open</code> 修饰的类。</p><p><strong>一个子类的访问级别不得高于父类的访问级别</strong>。</p><p>例如，父类的访问级别是 <code>internal</code>，子类的访问级别就不能是 <code>public</code>。</p><ul><li>此外，在同一模块中，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。</li><li>在不同模块中，你可以重写类中被 <code>open</code> 修饰的成员。</li></ul><p>可以通过重写给所继承类的成员提供更高的访问级别。</p><ul><li>下面的例子中，类 <code>A</code> 的访问级别是 <code>public</code>，它包含一个方法 <code>someMethod()</code>，访问级别为 <code>fileprivate</code>。</li><li>类 <code>B</code> 继承自类 <code>A</code>，访问级别为 <code>internal</code>，但是在类 <code>B</code> 中重写了类 <code>A</code> 中访问级别为 <code>fileprivate</code> 的方法 <code>someMethod()</code>，并重新指定为 <code>internal</code> 级别。</li></ul><p>通过这种方式，我们就可以将某类中 <code>fileprivate</code> 级别的类成员重新指定为更高的访问级别，以便其他人使用：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fileprivate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">internal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> internal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 <code>fileprivate</code> 级别的成员，在同一模块内访问父类 <code>internal</code> 级别的成员）：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    fileprivate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">internal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> internal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">someMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>因为父类 <code>A</code> 和子类 <code>B</code> 定义在同一个源文件中，所以在子类 <code>B</code> 可以在重写的 <code>someMethod()</code> 方法中调用 <code>super.someMethod()</code>。</p><h2 id="常量、变量、属性、下标" tabindex="-1">常量、变量、属性、下标 <a class="header-anchor" href="#常量、变量、属性、下标" aria-label="Permalink to &quot;常量、变量、属性、下标&quot;">​</a></h2><p>常量、变量、属性<strong>不能拥有比它们的类型更高的访问级别</strong>。</p><ul><li>例如，你不能定义一个 <code>public</code> 级别的属性，但是它的类型却是 <code>private</code> 级别的。</li><li>同样，下标也不能拥有比索引类型或返回类型更高的访问级别。</li></ul><p>如果常量、变量、属性、下标的类型是 <code>private</code> 级别的，那么它们必须明确指定访问级别为 <code>private</code>：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> privateInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SomePrivateClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="getter-和-setter" tabindex="-1"><code>Getter</code> 和 <code>Setter</code> <a class="header-anchor" href="#getter-和-setter" aria-label="Permalink to &quot;\`Getter\` 和 \`Setter\`&quot;">​</a></h3><p>常量、变量、属性、下标的 <strong><code>Getters</code> 和 <code>Setters</code> 的访问级别和它们所属类型的访问级别相同</strong>。</p><p><code>Setter</code> 的访问级别可以低于对应的 <code>Getter</code> 的访问级别，这样就可以控制变量、属性或下标的读写权限。</p><p>在 <code>var</code> 或 <code>subscript</code> 关键字之前，你可以通过 <code>fileprivate(set)</code>，<code>private(set)</code> 或 <code>internal(set)</code> 为它们的写入权限指定更低的访问级别。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>这个规则同时<strong>适用于存储型属性和计算型属性</strong>。</p><p>即使你不明确指定存储型属性的 <code>Getter</code> 和 <code>Setter</code>，Swift 也会隐式地为其创建 <code>Getter</code> 和 <code>Setter</code>，用于访问该属性的存储内容。</p><p>使用 <code>fileprivate(set)</code>，<code>private(set)</code> 和 <code>internal(set)</code> 可以改变 <code>Setter</code> 的访问级别，这对计算型属性也同样适用。</p></div><p>下面的例子中定义了一个名为 <code>TrackedString</code> 的结构体，它记录了 <code>value</code> 属性被修改的次数：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TrackedString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line highlighted"><wbr></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 存储 Int 值的属性 numberOfEdits，它用于记录属性 value 被修改的次数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numberOfEdits </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 存储 String 值的属性 value，并将初始值设为 &quot;&quot;（一个空字符串）。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 通过 didSet 观察器实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        didSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 每当给 value 赋新值时就会调用，然后将 numberOfEdits 的值加 1。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            numberOfEdits </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>结构体 <code>TrackedString</code> 和它的属性 <code>value</code> 都没有显式地指定访问级别，所以它们都是用默认的访问级别 <code>internal</code>。</li><li>但是该结构体的 <code>numberOfEdits</code> 属性使用了 <code>private(set)</code> 修饰符，这意味着 <code>numberOfEdits</code> 属性只能在结构体的定义中进行赋值。</li><li><code>numberOfEdits</code> 属性的 <code>Getter</code> 依然是默认的访问级别 <code>internal</code>，但是 <code>Setter</code> 的访问级别是 <code>private</code>，这表示该属性只能在内部修改，而在结构体的外部则表现为一个只读属性。</li></ul><p>如果你实例化 <code>TrackedString</code> 结构体，并多次对 <code>value</code> 属性的值进行修改，你就会看到 <code>numberOfEdits</code> 的值会随着修改次数而变化：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stringToEdit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TrackedString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stringToEdit.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;This string will be tracked.&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stringToEdit.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; This edit will increment numberOfEdits.&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stringToEdit.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; So will this one.&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;The number of edits is </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\\(stringToEdit.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">numberOfEdits</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印“The number of edits is 3”</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">虽然你可以在其他的源文件中实例化该结构体并且获取到 <code>numberOfEdits</code> 属性的值，但是你不能对其进行赋值</p><p>这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。</p></div><p>你可以在必要时为 <code>Getter</code> 和 <code>Setter</code> 显式指定访问级别。</p><p>下面的例子将 <code>TrackedString</code> 结构体明确指定为了 <code>public</code> 访问级别。</p><p>这时结构体的成员（包括 <code>numberOfEdits</code> 属性）拥有默认的访问级别 <code>internal</code>。</p><p>然后你可以结合 <code>public</code> 和 <code>private(set)</code> 修饰符：</p><ul><li>把结构体中的 <code>numberOfEdits</code> 属性的 <code>Getter</code> 的访问级别设置为 <code>public</code></li><li>而 <code>Setter</code> 的访问级别设置为 <code>private</code></li></ul><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TrackedString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numberOfEdits </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        didSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            numberOfEdits </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="构造器" tabindex="-1">构造器 <a class="header-anchor" href="#构造器" aria-label="Permalink to &quot;构造器&quot;">​</a></h2><p>自定义构造器的<strong>访问级别可以低于或等于其所属类型的访问级别</strong>。</p><div class="warning custom-block"><p class="custom-block-title">例外</p><p>唯一的例外是「必要构造器」，它的访问级别必须和所属类型的访问级别相同。</p></div><p>如同函数或方法的参数，<strong>构造器「参数」的访问级别也不能低于构造器「本身」的访问级别</strong>。</p><h3 id="默认构造器" tabindex="-1">默认构造器 <a class="header-anchor" href="#默认构造器" aria-label="Permalink to &quot;默认构造器&quot;">​</a></h3><p>Swift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。</p><p>默认构造器的访问级别<strong>与所属类型的访问级别相同，除非类型的访问级别是 <code>public</code></strong>。</p><ul><li>如果一个类型被指定为 <code>public</code> 级别，那么默认构造器的访问级别将为 <code>internal</code>。</li><li>如果你希望一个 <code>public</code> 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 <code>public</code> 访问级别的无参数构造器。</li></ul><h3 id="结构体默认的成员逐一构造器" tabindex="-1">结构体默认的成员逐一构造器 <a class="header-anchor" href="#结构体默认的成员逐一构造器" aria-label="Permalink to &quot;结构体默认的成员逐一构造器&quot;">​</a></h3><ul><li>如果结构体中<strong>任意存储型属性</strong>的访问级别为 <code>private</code>，那么该结构体默认的成员逐一构造器的访问级别就是 <code>private</code>。</li><li>否则，这种构造器的访问级别依然是 <code>internal</code>。</li></ul><p>如同前面提到的默认构造器，如果你希望一个 <code>public</code> 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 <code>public</code> 访问级别的成员逐一构造器。</p><h2 id="协议" tabindex="-1">协议 <a class="header-anchor" href="#协议" aria-label="Permalink to &quot;协议&quot;">​</a></h2><p>如果想为一个协议类型明确地指定访问级别，在<strong>声明协议时指定</strong>即可。</p><p>这将限制该协议只能在适当的访问级别范围内被遵循。</p><p>协议中的<strong>每个方法或属性都必须具有和该协议相同</strong>的访问级别。</p><ul><li>你不能将协议中的方法或属性设置为其他访问级别。</li><li>这样才能确保该协议的所有方法或属性对于任意遵循者都可用。</li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><p>如果你定义了一个 <code>public</code> 访问级别的协议，那么该协议的所有实现也会是 <code>public</code> 访问级别。</p><p>这一点不同于其他类型，例如，类型是 <code>public</code> 访问级别时，其成员的访问级别却只是 <code>internal</code>。</p></div><h3 id="协议继承" tabindex="-1">协议继承 <a class="header-anchor" href="#协议继承" aria-label="Permalink to &quot;协议继承&quot;">​</a></h3><p>如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别<strong>最高也只能和被继承协议的访问级别相同</strong>。</p><p>例如，你不能将继承自 <code>internal</code> 协议的新协议访问级别指定为 <code>public</code> 。</p><h3 id="协议遵循" tabindex="-1">协议遵循 <a class="header-anchor" href="#协议遵循" aria-label="Permalink to &quot;协议遵循&quot;">​</a></h3><ul><li>一个<strong>类可以遵循比它级别更低的协议</strong>。</li></ul><p>例如，你可以定义一个 <code>public</code> 级别类，它能在别的模块中使用，但是如果它遵循一个 <code>internal</code> 协议，这个遵循的部分就只能在这个 <code>internal</code> 协议所在的模块中使用。</p><ul><li>遵循协议时的<strong>上下文级别是类和协议中级别最小的那个</strong>。</li></ul><p>如果一个类型是 <code>public</code> 级别，但它要遵循的协议是 <code>internal</code> 级别，那么这个类型对该协议的遵循上下文就是 <code>internal</code> 级别。</p><ul><li>当你编写或扩展一个类让它遵循一个协议时，你必须<strong>确保该类对协议的每一个要求的实现，至少与遵循协议的上下文级别一致</strong>。</li></ul><p>例如，一个 <code>public</code> 类型遵循一个 <code>internal</code> 协议，这个类型对协议的所有实现至少都应是 <code>internal</code> 级别的。</p><h3 id="extension" tabindex="-1"><code>Extension</code> <a class="header-anchor" href="#extension" aria-label="Permalink to &quot;\`Extension\`&quot;">​</a></h3><p><code>Extension</code> 可以<strong>在访问级别允许的情况下</strong>对类、结构体、枚举进行扩展。</p><p><code>Extension</code> 的「<strong>新增成员」具有和「原始类型」成员一致的访问级别</strong>。</p><ul><li>例如，你使用 <code>extension</code> 扩展了一个 <code>public</code> 或者 <code>internal</code> 类型，则 <code>extension</code> 中的成员就默认使用 <code>internal</code> 访问级别。</li><li>如果你使用 <code>extension</code> 扩展一个 <code>fileprivate</code> 类型，则 <code>extension</code> 中的成员默认使用 <code>fileprivate</code> 访问级别。</li><li>如果你使用 <code>extension</code> 扩展了一个 <code>private</code> 类型，则 <code>extension</code> 的成员默认使用 <code>private</code> 访问级别。</li></ul><p>或者，你可以通过修饰语重新指定 <code>extension</code> 的默认访问级别（例如，<code>private</code>），从而给该 <code>extension</code> 中的所有成员指定一个新的默认访问级别。</p><p>这个新的默认访问级别仍然可以被单独成员指定的访问级别所覆盖。</p><div class="tip custom-block"><p class="custom-block-title">如果你使用 <code>extension</code> 来遵循协议的话，就不能显式地声明 <code>extension</code> 的访问级别</p><p><code>extension</code> 每个 <code>protocol</code> 要求的实现都默认使用 <code>protocol</code> 的访问级别。</p></div><h4 id="extension-的私有成员" tabindex="-1"><code>Extension</code> 的私有成员 <a class="header-anchor" href="#extension-的私有成员" aria-label="Permalink to &quot;\`Extension\` 的私有成员&quot;">​</a></h4><p>扩展同一文件内的类，结构体或者枚举，<code>extension</code> 里的代码会<strong>表现得跟声明在原类里的一模一样</strong>。</p><p>也就是说你可以这样：</p><ul><li>在类的声明里声明一个私有成员，在同一文件的 <code>extension</code> 里访问。</li><li>在 <code>extension</code> 里声明一个私有成员，在同一文件的另一个 <code>extension</code> 里访问。</li><li>在 <code>extension</code> 里声明一个私有成员，在同一文件的类型声明里访问。</li></ul><p>这意味着你<strong>可以使用 <code>extension</code> 来组织你的代码，而且不受私有成员的影响</strong>。</p><p>例如，给定下面这样一个简单的协议：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeProtocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你可以使用 <code>extension</code> 来遵循协议，就像这样：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> privateVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extension</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SomeStruct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SomeProtocol </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(privateVariable)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="泛型" tabindex="-1">泛型 <a class="header-anchor" href="#泛型" aria-label="Permalink to &quot;泛型&quot;">​</a></h2><p>泛型类或泛型函数的访问级别：</p><ul><li><strong>取决于泛型类或泛型函数本身</strong>的访问级别</li><li>还需结合类参数的类型约束的访问级别</li></ul><p>根据这些访问级别中的最低访问级别来确定。</p><h2 id="类别名" tabindex="-1">类别名 <a class="header-anchor" href="#类别名" aria-label="Permalink to &quot;类别名&quot;">​</a></h2><p>你定义的任何类别名都会被当作不同的类型，以便于进行访问控制。</p><p><strong>类别名的访问级别不可高于其表示的类的访问级别</strong>。</p><p>例如，<code>private</code> 级别的类型别名可以作为 <code>private</code>、<code>fileprivate</code>、<code>internal</code>、<code>public</code> 或者 <code>open</code> 类型的别名，但是 <code>public</code> 级别的类型别名只能作为 <code>public</code> 类型的别名，不能作为 <code>internal</code>、<code>fileprivate</code> 或 <code>private</code> 类型的别名。</p>`,166),l=[t];function p(h,d,o,k,c,r){return a(),i("div",null,l)}const u=s(n,[["render",p]]);export{E as __pageData,u as default};
